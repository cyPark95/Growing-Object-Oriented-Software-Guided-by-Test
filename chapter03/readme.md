# 3장 도구 소개

## 3.1 이미 아는 내용이라면 넘어가도 좋다

- 이 책에서 다룰 예제는 자바(Java)를 기반으로 한다.
- 사용 도구
    - JUnit 4 (단위 테스트 프레임워크)
    - Hamcrest (테스트 결과를 가독성 있게 표현하는 매처 라이브러리)
    - jMock2 (목 객체 프레임워크)

## 3.2 간략한 JUnit 4 소개

- JUnit은 리플렉션(reflection)을 이용해 클래스 구조를 파악한 후 클래스 내에서 테스트를 나타내는 메서드를 모두 실행한다.

### 3.2.1 테스트 케이스

- `@Test` 어노테이션이 지정된 메서드는 모두 테스트 케이스로 취급한다.
- JUnit의 테스트 메서드 제약
    - 값을 반환하지 않아야 한다.
    - 매개변수를 받지 않아야 한다.
- JUnit은 테스트 실행 시, 테스트 클래스의 새로운 인스턴스를 만들고, 인스턴스에서 적절한 테스트 메서드를 호출한다.
- 매번 새로운 테스트 객체가 만들어지므로, 테스트 간 격리성을 확보할 수 있다.
    - 테스트에서 객체의 필드 값을 변경해도 다른 테스트에는 영향을 주지 않는다.

### 3.2.2 단정

- JUnit 테스트에서는 테스트 대상 객체를 호출하고, 그 결과를 단정(assertion) 한다.
- JUnit에서는 여러 단정 메서드를 제공한다.
- 단정이 실패하면, 유용한 오류 메시지를 출력한다.

### 3.2.3 예외 예상하기

- JUnit의 `@Test` 어노테이션은 `expected` 매개변수를 사용하여 테스트 실행 중 특정 예외가 발생할 것으로 선언할 수 있다.
- 테스트에서 예외가 발생하지 않거나, 다른 유형의 예외가 발생하면 테스트는 실패한다.

### 3.2.4 테스트 픽스처

- 테스트 픽스처(Test Fixture)
    - 테스트가 시작될 때 존재하는 고정된 상태를 의미한다.
    - 테스트의 반복 가능성(repeatability)을 보장한다.
    - 테스트 실행되기 전에 준비해서(set up) 테스트 실행이 완료된 후에 정리(tear down)할 수 있다.
- JUnit 테스트에서 사용되는 픽스처는 해당 테스트 클래스에서 관리하고, 클래스의 필드에 저장된다.
    - 같은 테스트 클래스에 정의된 모든 테스트는 동일한 초기 픽스처로 시작한다.
    - 테스트 도중 픽스처 내용을 변경해도, 다른 테스트에는 영향을 주지 않는다.
- 픽스처 관리
    - 일반적으로 필드 초기화자(initializer), 생성자, 또는 인스턴스 초기화 블록에서 픽스처를 설정한다.
    - JUnit은 테스트 실행 전 `@Before` 어노테이션이 지정된 초기화 메서드를 호출한다.
    - JUnit은 테스트가 실행된 후 `@After` 어노테이션이 지정된 정리 메서드를 호출한다.
- JVM의 가비지 컬렉션으로 테스트 중 생성된 객체를 자동으로 회수하기 때문에 명시적으로 픽스처를 정리하지 않아도 된다.

### 3.2.5 테스트 러너

- 테스트 러너(Test Runner)
    - JUnit은 클래스를 대상으로 리플렉션을 통해 테스트 찾고, 테스트 러너는 테스트를 실행하는 방식을 제어한다.
    - `@RunWith` 어노테이션을 사용해 특정 테스트 러너를 지정할 수 있다.
- jMock 라이브러리의 경우 맞춤형 테스트 러너를 이용해 테스트가 끝나고 테스트 픽스처가 정리되기 전에 목 객체를 자동으로 검증한다.

## 3.3 햄크레스트 매처와 assertThat()

- 햄크레스트(Hamcrest)
    - 테스트에서 조건을 선언적으로 표현할 수 있도록 도와주는 매칭 프레임워크다.
- 매처(Matcher)
    - 특정 객체가 주어진 조건과 일치하는지를 판단한다.
    - 테스트 조건이나 어떤 조건과 일치하지 않는 이유를 기술할 수 있다.
    - 모든 매처는 코드의 가독성을 높이기 위해 정적 팩터리 메서드(static factory method) 형태로 제공된다.
- `assertThat()`과 조합
    - JUnit의 `assertThat()` 메서드와 함께 사용한다.
    - `assertThat()`은 매처의 자기서술적(self-describing) 특성을 활용해, 단정이 실패했을 때 무엇이 잘못됐는지 분명하게 보여준다.
- 매처 조합
    - 기존 매처를 조합해 새로운 조건을 정의할 수 있다.
    - 여러 매처를 조합하더라도 실패 메시지의 자기서술적인 특성은 유지된다.
- 필요에 따라 사용자가 직접 `Matcher` 인터페이스를 구현하고, 의미 있는 이름의 팩터리 메서드를 추가하여 새로운 매처를 추가할 수 있다.

## 3.4 jMock2: 목 객체

- jMock2
    - JUnit(또는 다른 테스트 프레임워크)과 통합되어 목 객체(mock object) 기반의 테스트를 지원하는 라이브러리다.
    - 테스트 대상 객체가 의존하는 협력 객체를 동적으로 생성하므로, 실제 구현체를 직접 작성할 필요가 없다.
    - 테스트 중 목 객체가 어떻게 호출되고, 어떻게 응답해야 할지 지정할 수 있는 고수준 API를 제공한다.

> jMock 이해
>
> 예상 구문(expectation)을 명확히 기술하는 것으로 테스트는 결과값 검증뿐 아니라 객체 간 협력 관계를 명확하게 표현해야 한다.

- jMock API 핵심 개념
    - 모조 객체(Mockery)
        - 테스트 컨텍스트 전체를 표현하며, 테스트 중 생성되는 모든 목 객체를 관리한다.
    - 목 객체(Mock Object)
        - 테스트 대상 객체의 협력 객체를 대신한다.
    - 예상 구문(Expectation)
        - 테스트 대상 객체가 협력 객체를 어떻게 호출해야 하는지 기술한다.

### 3.4.1 예상 구문

- jMock의 예상 구문 API는 표현력이 뛰어나며, 협력 객체와의 상호작용을 지정할 수 있다.
    - 호출 횟수 제어
        - 예상되는 메서드 호출의 최소/최대 횟수를 지정할 수 있다.
    - 호출 허용 여부
        - 특정 메서드가 반드시 호출되어야 하는지 혹은 단순히 호출되어도 괜찮은지를 명시할 수 있다.
        - 지정된 호출이 발생하지 않으면 테스트가 실패하며, 허용된 호출은 일어나지 않아도 테스트가 통과한다.
    - 매개변수 제약
        - 메서드 인자에 대해 상수 값이나 햄크레스트 매처를 이용해 일치 조건을 지정할 수 있다.
    - 호출 순서 제약
        - 다른 예상 구문 간의 호출 순서를 지정할 수 있다.
    - 호출 시 동작 정의
        - 해당 메서드가 호출될 때 값을 반환하거나, 예외를 던지거나, 특정 동작을 수행하도록 지정할 수 있다.
- 코드 구조의 목적
    - jMock의 예상 구문 블록(expectations block)은 테스트 코드 내에서 다음 두 부분을 명확히 구분하기 위해 설계되었다.
        - 협력 객체가 어떻게 호출되어야 하는지를 기술하는 부분
        - 실제 테스트 대상 객체를 호출하고 결과를 검증하는 부분
