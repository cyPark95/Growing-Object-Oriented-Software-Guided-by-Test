# 7장 객체 지향 설계의 달성

## 7.1 테스트를 먼저 작성하는 것이 설계에 어떻게 도움이 되는

- 객체 지향 설계의 핵심 원칙은 객체의 올바른 경계를 찾고, 이웃 객체와 적절히 상호작용하도록 만드는 것이다.
    - 이렇게 만들어진 시스템은 요구사항이 변경될 때 재구성과 적응에 필요한 유연함을 갖출 수 있다.
    - 호출자는 객체가 무엇에 의존하는지는 알고 싶지만, 어떻게 동작하는지는 관심사가 아니다.
    - 객체는 자신이 속한 더 큰 환경 속에서도 응집력 있는 단위로 동작해야 한다.
    - 이러한 구조는 요구사항이 변경될 때, 재구성과 적응에 필요한 유연함을 갖출 수 있다.
- TDD가 설계에 기여하는 세 가지 측면
    - 테스트를 먼저 작성한다는 것은 '어떻게(How)'를 고민하기 전에, '무엇(What)'을 달성해야 하는가를 정의해야 한다.
        - 대상 객체에 대한 추상화 수준을 적절하게 유지하는 데 기여한다.
        - 테스트를 작성할 때는 객체 외부에서 무엇을 볼 수 있는가를 결정해야 하므로 정보 은닉에 도움을 준다.
    - 단위 테스트는 객체의 적절한 범위와 경계를 알려준다.
        - 테스트가 너무 길거나 복잡하다면 더 작은 단위의 컴포넌트로 재구성해야 한다는 신호다.
        - 이런 과정을 통해 생성된 복합 객체는 관리되는 책임이 명확해지고, 더 단순하고 집중된 테스트를 작성할 수 있다.
    - 단위 테스트를 의존성을 명확하게 드러낸다.
        - 단위 테스트를 위해 대상 객체를 생성하려면 의존성을 명시적으로 전달해야 하기 때문에 콘텍스트 독립성이 높아진다.
        - 의존성이 암시적이거나 너무 많으면 테스트 준비가 어렵고, 설계도 복잡하다는 신호다.

## 7.2 분류보다 의사소통

- 우리는 실행 중인 시스템을 상호 작용하는 객체의 망으로 바라보기 때문에 상속 보다는 어떻게 메시지를 주고 받을지에 대한 설계을 노력한다.
- 자바는 인터페이스를 통해 객체끼리 통신할 메시지를 정의하지만, 의사소통 패턴은 통신 프로토콜(메시지를 주고 받는 순서와 맥락)도 정의해야 한다.

> 인터페이스와 프로토콜
> - 인터페이스: "두 컴포넌트가 서로 연결될 수 있는가"를 기술
> - 프로토콜: "그 둘이 실제로 협력해서 잘 작동하는가"를 기술

- 통신 프로토콜은 드러내는 설계 도구로 목(Mock) 객체 기반 TDD를 이용한다.
    - 개발 과정에서 통신 프로토콜을 구체화할 뿐만 아니라, 해당 코드의 의도로도 작용한다.
    - 구현 없이 협력 관계를 설계할 수 있어 정보 은닉을 촉진 한다.
    - 목 객체는 객체의 이웃(peer) -의존성, 알림 조정- 과 관례슷 설계할 때 사용된다.
        - 인접 요소를 강조하는 테스트는 진짜 ‘이웃’인지 아니면 내부에 숨겨야 할 구현인지 판단하게 해준다.
        - 너무 복잡하거나 불분명한 테스트는 구현 세부 사항을 너무 드러냈거나 내부와 외부의 경계가 불명확하다는 신호다.

## 7.3 값 타입

- 도메인에서 값의 개념을 나타는 타입을 정의하고 사용해야 한다.
    - 자체로 설명 가능한 도메인 모델이 된다.
    - 구체적인 타입은 혼동의 위험을 줄인다.
    - 값에 행위를 추가하기 쉬워진다.
- 값 타입을 도입하기 위한 세 가지 기법
    - 분해(Breaking out)
        - 코드가 복잡해지고, 다수의 관심사를 구현하기 시작하면, 별도의 응집된 단위로 분리하라는 신호로 볼 수 있다.
    - 파생(Budding off)
        - 코드에서 새 도메인 개념이 드러날 때 필드 하나만 가진 단순한 타입이나 필드가 없는 위치 지정자(placeholder) 타입을 도입한다.
        - 규모가 커지면 필드와 메서드를 추가하고, 추가한 타입을 이용해 코드 추상화 수준을 높일 수 있다.
    - 포장(bundling up)
        - 늘 함께 사용되는 여러 값이 있는 경우, 그 값 들이 포함된 하나의 새로운 타입으로 정의한다.
        - 새 타입에 관련 필드를 인터페이스 너머로 감출 수 있고, "전체는 부분의 합보다 단순해야 한다" 규칙을 만족시킬 수 있다.

## 7.4 객체는 어디에서 오는가?

- 단위 테스트는 코드의 내부 품질을 유지하고 좋은 설계에 영향을 미치는 핵심 도구다.

### 7.4.1 분해: 큰 객체를 협력 객체의 그룹으로 나누기

- 설계 판단을 중단하고 새로운 기능을 구현하게 되면, 일정 수준의 경험과 맥락을 이해할 수 있지만 결국 코드가 복잡해져 정리해야할 시점이 온다.
- 응집력 있는 기능 단위를 더 작은 협력 객체로 분해해야 한다.
    - 독립적으로 단위 테스트가 가능해진다.
    - 분해 과정에서 의존성 관계를 자연스럽게 파악할 수 있다.
- 정리 작업을 미루면 발생하는 문제
    - 언제 정리할지 모른 채 다음 기능으로 넘어가게 된다.
        - 시간의 압박 속에서 정리가 필요한 코드를 놔두고 다음 작업으로 넘어가려는 유혹에 빠지기 쉽다.
    - 복잡해진 코드는 삭제하고 다시 구현하는 편이 나을 때도 있다.

> 테스트 가라사대...
> - 테스트할 수 없을 정도로 덩치가 크거나, 실패 원인을 파악하기 어려운 객체는 분해가 필요하다.
> - 분해한 부분을 따로 단위테스트 한다.

### 7.4.2 파생: 객체가 필요로 하는 신규 서비스 정의와 해당 서비스를 제공하기 위한 새 객체 추가

- 코드가 어느 정도 안정화되고 구조를 갖추면, 객체 간 협력 속에서 새로운 타입과 책임이 드러난다.
- 새로운 기능은 설계 원칙에 속하지 않는 사실을 발견할 수 있다.
    - 이런 경우 인터페이스를 만들어 객체 관점에서 필요한 서비스를 정의한다.
    - 대상 객체와 협력 객체 간의 관계는 목 객체를 사용해 해당 서비스가 존재하는 것처럼 테스트를 작성한다.
- 새로운 서비스 정의 과정
    - 기존 객체를 구현하는 도중, 해당 객체가 다른 객체로부터 받아야 할 서비스가 필요하다는 사실을 깨닫는다.
    - 새로운 서비스에 이름을 부여하고, 클라이언트 객체와 관계를 명확히 하기 위해 단위 테스트 바깥에서 목 객체로 만들어 제공한다.
    - 서비스를 제공하는 구현체를 작성하는데, 이 과정에서 객체가 필요한 서비스를 파악할 수 있다.
    - 객체들이 협력하는 관계가 형성되는과정에서 또 다른 협력 관계나 의존성이 드러나면 같은 절차를 반복한다.
    - 이런 방식으로 '입력에서 출력 방향으로 개발하라'를 구현할 수 있다.
- 이를 '주문형(on-demand)' 설계다.
    - 제공해야 할 기능을 미리 계획해서 설계(push) 하는 방식이 아닌, 필요한 기능을 요구(on-demand)할 때 설계하는 것이다.

> 테스트 가라사대...
>  - 테스트를 작성 할 때 기능에 대한 의문이 든다면 책임이 잘못된 곳에 있다는 신호다.
>  - 이런 경우 새로운 협력 객체를 도입해 역할을 분리하면 시스템의 구조가 명확해진다.

### 7.4.3 포장: 관련 객체를 포함 객체로 감추기

- "전체는 부분의 합보다 단순해야 한다" 규칙의 응용이다.
- 함께 사용되는 객체의 집합을 하나의 새로운 객체로 포장하면 얻을 수 있는 효과
    - 기존 집합의 복잡성을 추상화 너머로 감춰 더 높은 수준에서 프로그램을 작성할 수 있다.
    - 객체 집합에 의미 있는 이름을 부여함으로써 도메인의 개념을 더 잘 드러낼 수 있다.
    - 개념의 경계를 확인할 수 있으므로 의존성의 범위를 좀 더 명확하게 한정할 수 있다.
    - 단위 테스트를 좀 더 정확하게 수행할 수 있다.
        - 객체 집합을 직접 테스트 할 수도 있고, 목 객체를 통해 테스트를 단순화 할 수 있다.

> 테스트 가라사대...
> - 테스트 코드에서 객체를 생성하기가 너무 복잡하거나, 협력 객체의 수가 많아 설정이 어렵다면 협력 객체의 일부를 포장하는 방법을 고려할 수 있다.

## 7.5 인터페이스로 관계를 식별하라

- 인터페이스는 객체의 통신 프로토콜에서 규정한 관계를 드러내는 도구다.
- 인터페이스는 작은 범위로 유지해야 한다.
    - 정의된 메서드가 많을수록 역할이 모호해진다.
    - 핵심적인 행위만 정의한다면 객체의 책임이 선명해진다.
    - 인터페이스의 범위가 좁으면 어댑터(adapter)와 데코레이터(decorator)를 구현하기 쉽다.
- '주문형(on-demand)' 설계 방식으로 진행하면 불필요한 구현을 방지할 수 있다.
    - 객체 간의 암시적인 결합이 최소화되고 코드는 변경하기 쉬운 상태에 머물게 된다.

> Impl 클래스는 의미를 충분히 드러내지 않는다
>
> - 클래스 이름은 클래스의 역할을 설명할 수 있어야 한다.
> - 좋은 구현체 이름이 없다면 인터페이스 적절하지 않은 이름이거나, 잘못 설계됐을 가능성이 높다.

## 7.6 인터페이스도 리팩터링하라

- 프로토콜과 인터페이스를 갖추면 유사점과 차이점이 드러난다.
- 유사한 인터페이스는 병합을 고려할 수 있다.
    - "착탈 가능한(plug-and-play)" 컴포넌트가 늘어, 더 유연한 상태가 되므로 더 높은 수준의 추상화로 작업할 수 있다.
    - 개발자가 이해해야 할 개념이 줄어든다.
- 서로 다른 인터페이스는 분리해애야 한다.
    - 다른 개념을 표현하는 인터페이스들은 구별 가능해야 한다.
    - 인터페이스들의 경계가 명확할수록 객체를 올바르게 조합하고 있다는 확신을 가질 수 있다.
- 구현하기 시작하는 시점에도 인터페이스 리팩터링을 고려할 수 있다.
    - 구현 클래스 구조가 불분명하다면, 인터페이스가 너무 많은 책임을 맡고 있다는 신호다.
    - 이런 경우 인터페이스를 분리하고, 이름을 재검토해야한다.

## 7.7 객체를 구성해야 시스템의 행위를 기술하라

- 단위 수준의 TDD는 시스템을 구성하는 객체를 분해하고 조합하는 과정의 방향성을 제시한다.
    - 테스트 객체가 어떻게 행동해야 하는지, 서로 어떻게 결합될 수 있는지 드러난다.
    - 이렇게 하면 저수준 객체를 기능이 풍부한 기본 구성 요소로 사용할 수 있다.
- jMock의 Mockery는 시스템 행위를 정의하는 강력한 도구다.
    - 예상된 호출을 `Mockery` 콘텍스트 내에서 조합한다.
    - 대상 객체를 상대로 실제 호출 `Expectation`에 전달하고, 일치 여부를 검사한다.

<img width="1000" height="400" alt="Image" src="https://github.com/user-attachments/assets/d30a6970-4987-429d-bb1b-f181c2c20587" />

- 이런 구조는 적은 코드로 유연한 애플리케이션 구조가 만들어진다.
    - 시스템을 작은 단위의 컴포넌트로 나누어, 서로 다른 시나리오나 구성 요소 조합을 쉽게 실험할 수 있다.
    - 새로운 착탈 가능한 컴포넌트를 추가하면 되기 때문에 쉽게 확장할 수 있다.

## 7.8  고수준 프로그래밍을 위한 대비

- 테스트 코드에서 예상 구문(expectation)을 표현하는 것은 본질적으로 어려운 일이다.
- 객체의 관계망을 조립하는 일은 간단하지만, 자바의 경우 문법적 키워드, 설정자, 표기법 등으로 인해 코드에서 의도가 문법에 묻혀버린다.
- 문제를 해결하기 위해 코드를 두 가지 계층으로 구성한다.
    - 구현 계층 (Implementation Layer)
        - 객체 그래프를 구성하고, 이벤트에 대한 반응을 정의한다.
        - "코드가 어떻게 동작하는가"를 기술한다.
    - 선언적 계층 (Declarative Layer)
        - 구현 계층의 객체들을 조합해 행위를 기술한다.
        - “코드가 무엇을 하려는가”를 표현한다.
    - 두 계층은 서로 다른 코딩 스타일을 사용한다.
        - 구현 계층은 전통적인 객체지향 설계 원칙을 따른다.
        - 선언적 계층은 좀 더 융통성있는 스타일을 허용한다.
- jMock의 API는 "무엇을 테스트하는지" 표현하는 도메인 특화 언어 형태를 사용한다.
  <img width="1000" height="500" alt="Image" src="https://github.com/user-attachments/assets/12027351-36b5-481e-ae32-8c531d44fb3c" />
- 일반적으로 선언적 계층은 리팩터링을 거듭하면서 자연스럽게 등장한다.
    - 처음에는 직접 객체를 구성하고 중복 제거에 집중한다.
    - 반복되는 패턴을 도우미 메서드로 분리한다.
    - 문법적 잡음을 줄이며, 코드의 의도를 작 표현하는 형태로 수정한다.
    - 자연스럽게 코드가 두 계층 구조로 분리되어 있다는 사실을 발견하게 된다.
- 목표는 더 적은 코드로 더 많은 행위를 표현하는 것이다.

## 7.9 그럼 클래스는?

- 객체의 타입은 클래스 이름이 아니라, 객체가 수행하는 역할로 규정된다.
- 클래스는 '구현 세부 사항'이 아니라, 타입을 구현하는 하나의 방식이다.
- 공통적인 행위를 추려내 객체 클래스 계층 구조를 파악하고, 가능하다면 위임으로 리팩터링하는 방식을 선호한다.
- 공통적인 행위를 추출할 때, 상속보다는 위임(delegation)으로 리팩터링하는 것이 좋다.
    - 위임은 코드를 더 유연하고, 이해하기 쉽게 만든다.
    - 하지만 값 타입은 동위 요소가 없어 위임을 사용할 가능성이 낮다.
