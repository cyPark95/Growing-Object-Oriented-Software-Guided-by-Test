# 2장 객체를 활용한 테스트 주도 개발

## 2.1 객체망

- 객체지향 설계
    - 객체 자체보다는 객체 간의 의사소통에 집중한다.
    - 객체는 메시지를 주고받으며 반응한다.
    - 메시지를 처리하는 메서드(method)를 가지고 있으며, 내부 상태를 캡슐화한다.
- 객체 지향 시스템
    - 객체 지향 시스템은 협업하는 객체들의 망(Network)으로 구성된다.
    - 시스템의 행위는 객체의 조합(객체의 선택과 연결 방식)을 통해 나타난다.
- 객체의 구성을 관리하는 코드를 객체망의 행위에 대한 선언적(declarative) 정의라고 한다.
- 이런 시스템은 방법(how)이 아닌 목적(what)에 집중할 수 있어 시스템의 행위를 변경하기 쉽다.

## 2.2 값과 객체

- 시스템을 설계할 때 값(value)과 객체(object)의 구분이 중요하다.
    - 값: 변하지 않는 양이나 크기
    - 객체: 시간이 지남에 따라 상태가 변할 수 있으며, 식별자(identity)를 가지는 계산 철자(computational process)
- 값 (Value)
    - 고정된 불변 인스턴스로, 상태가 같다면 동일하다.
    - 별도의 식별자는 의미가 없다.
    - 값 비교 시 식별자(`==`)가 아니라 내용 비교(`equals`)를 사용해야 한다.
- 객체 (Object)
    - 변경 가능한 상태를 이용해 시간의 흐름에 따른 객체의 행위를 나타낸다.
    - 같은 타입이고 동일한 상태를 가지고 있어도 별도의 식별자를 지닌다.
    - 향후 어떤 메시지를 전달받느냐에 따라 상태가 달라질 수 있다.
- 실무에서는 시스템을 기능적으로 다루는 값과 시스템에서 상태를 지닌 행위를 구현하는 객체 두 가지 '진영'으로 나눠 바라볼 수 있다.

## 2.3 메시지를 따르라

- 다른 객체와 쉽게 관계를 맺을 수 있도록 객체를 설계하면, 고수준의 선언적 접근법의 이점을 얻을 수 있다.
- 이는 객체가 일반적인 의사소통 패턴을 따르고, 객체 간의 의존성이 명시적임을 의미한다.
- 의사소통 패턴
    - 객체들이 서로 어떻게 상호 작용하는지 관장하는 각종 규칙 집합
        - 객체의 역할
        - 전달 가능한 메시지
        - 메시지를 전달할 수 있는 시점
- 자바같은 언어는 구현 클래스 대신 추상 인터페이스를 통해 객체의 역할을 드러내는 것이 적절하다.
- 도메인 모델은 객체 간 관계에 의미를 부여하는 의사소통 패턴에 속한다.
- 시스템을 의사소통 구조 관점에서 바라보면, 의사소통 구조는 정적인 분류에서 개념적으로 발전된 개념이다.
- 하지만 의사소통 패턴은 프로그래밍 언어로 명확하게 표현되지 않기 때문에 도메인 모델은 명확하게 드러나지 않는다.
- 정적인 분류와 동적인 의사소통 간의 불일치로 인해 설계가 복잡해진다.
    - 정적인 분류: 상속은 공통 기능 공유에는 유용하지만, 여러 역할을 표현하기에는 한계가 있다.
    - 동적인 의사소통: 객체는 상황에 따라 다양한 역할을 수행하므로, 단순한 계층 구조만으로는 표현하기 어렵다.

> 역할, 책임, 협력자
>
> - 역할(Role): 관련된 책임들의 집합
> - 책임(Responsibility): 객체가 수행해야 하는 과업이나 알아야 할 정보
> - 협력(Collaboration): 객체나 역할(또는 둘 다)의 상호작용

## 2.4 묻지 말고 말하라

- 객체는 무엇을 원하는지만 요청하고, 어떻게 수행할지는 요청받은 객체가 스스로 결정한다.
- 이 원칙은 디미터의 법칙(Law of Demeter) 으로도 알려져 있다.
- 객체는 다른 객체의 의존 없이 내부에 보유한 정보나 메시지를 통해 얻은 정보만을 이용해 의사결정을 내려야 한다.
    - 유연한 코드
        - 동일한 역할을 하는 객체로 쉽게 교체할 수 있다.
    - 낮은 결합도
        - 호출자는 내부 구조를 몰라도 된다.
    - 설계 변경에 안전
        - 변경이 일어나도 코드 전체에 미치는 영향이 줄어든다.
    - 가독성
        - 객체 간 상호작용이 명시적이다.
        - 메서드에 이름을 부여하여 코드의 목적이 명확해진다.
- 안좋은 예시: 열차 전복 코드(Train Wreck)
    ```java
    ((EditSaveCustomizer) master.getModelisable()
        .getDockablePanel()
            .getCustomizer()
                .getSaveItem().setEnabled(Boolean.False.booleanValue());
    ```
- 개선 예시: 묻지 말고 말하라(Tell, Don't Ask)
    ```java
    master.allowSavingOfCustomisations();
    ```
    - 호출자는 더 이상 반환 타입이나 내부 구조를 알 필요가 없다.
    - "커스터마이징 저장을 허용한다."는 의미를 명확하게 표현한다.

## 2.5 그래도 가끔은 물어라

- 경우에 따라 질문이 필요한 상황도 존재한다.
    - 질의 시에도 내부 구조를 드러내면 안 된다.
    - 단순히 속성을 꺼내는 대신, 객체가 스스로 답할 수 있는 질문을 던져야 한다.
    - 질의 메서드는 호출자의 의도를 표현해야 한다.
        - 적절한 객체에 행위가 자리 잡아 이해하기 쉬운 이름이 생긴다.
        - 테스트가 쉬워진다.
- 객체에 관한 질의를 남발하면 객체의 정보가 바깥으로 새어나가 시스템을 더 경직되게 만들 수 있다.
- 따라서 구현 세부가 아닌 호출다의 의도를 서술하는 질의를 작성해야한다.

## 2.6 협력 객체의 단위 테스트

- 단정문이 없는 테스트 상황
    - 테스트에서 직접 단정문(assert)을 쓸 부분이 없는 경우, 협력 객체를 목 객체(mock object)로 대체한다.
        - 예상 구문(expectation): 특정 이벤트에 대해 협력 객체가 어떻게 상호 작용할지 명세
        - 스텁(stub): 상황에 따라 필요한 행위를 단순히 흉내내는 구현
- TDD 접근 방식의 전환
    - 목 객체 기반 테스트가 가능해지면, 실제 단위 테스트에서 협력 객체의 내부 구현 여부를 알 필요가 없다.
    - 테스트 작성 과정에서 필요한 보조 역할을 파악하게 된다.
    - 보조 역할은 자바 인터페이스로 정의되며, 시스템의 나머지 부분을 개발할 때 실제 구현처럼 동작한다.
    - 이런 과정을 인터페이스 발견(interface discovery)라고 한다.

## 2.7 목 객체를 활용한 TDD 지원

- 목 객체를 활용한 테스트 지원

  <img width="350" height="250" alt="Image" src="https://github.com/user-attachments/assets/862f098c-a1ed-42c1-8f89-4ef3bd83a68a" />
  
    - 이웃하는 객체를 목(mock) 인스턴스로 대체한다.
    - 목 객체가 어떻게 호출되고 어떤 상태를 보여야 하는지에 대한 예상 구문을 정의한다.
    - 필요한 경우, 테스트를 진행할 수 있도록 목 객체가 스텁 형태로 동작할 행위를 구현한다.
- 목 객체를 활용한 테스트 구조
    - 필요한 목 객체 생성
    - 대상 객체를 포함한 실제 객체 생성
    - 대상 객체에서 목 객체가 어떻게 호출될지 예상하는 바를 기술
    - 대상 객체에서 유발(trigger) 메서드(하나 또는 여러 개)를 호출
    - 결과 값이 유효하고 예상되는 메서드 호출이 모두 일어났는지 확인
- 목 객체 기반 TDD 효과
    - 단위 테스트는 대상 객체를 둘러싼 환경 간의 관계를 명확히 드러낸다.
    - 단위 테스트는 단순히 결과 값만 확인하는 것이 아니라, 협력 객체와의 상호 작용 자체를 검증한다.

> 책 전반에 걸친 핵심 메시지
> 
> - 모든 테스트의 의도를 명확하게 해야한다.
> - 테스트를 거친 기능과 보조 역할을 담당하는 기반 구조, 객체 구조를 구분해야 한다.
