# 6장 객체 지향 스타일

- 작성하기 쉬운 코드보다 유지보수하기 쉬운 코드를 높게 평가한다.
- 직접적인 방식으로 기능을 구현하면 유지보수성이 떨어진다.
    - 코드의 의도와 구조를 이해하기 어렵다.
    - 컴포넌트 간의 보이지 않는 의존성이 생긴다.
    - 단기적 편의와 장기적 품질 사이의 균형을 유지하는 일은 까다로운 문제다.

## 6.1 유지 보수성을 고려한 설계

- 코드 규모가 커질 경우 이해하고 유지보수하기 위해서 구조화가 필요하다.
    - 기능은 객체로, 객체는 패키지로, 패키지는 프로그램으로, 프로그램은 시스템으로 구성되어야 한다.
- 관심사 분리(Separation of Concerns)
    - 유지보수의 핵심은 변경의 영향 범위를 최소화하는 것이다.
    - 관련된 변경 사항은 한곳에 모으고, 서로 다른 이유로 변경되는 코드들이 섞이지 않게 해야 한다.
- 더 높은 수준의 추상화(Abstraction)
    - 복잡성을 다루는 유일한 방법은 더 높은 수준의 추상화를 활용해 복잡성을 피하는 것이다.
    - 변수나 제어 흐름 같은 저수준 조작 대신, 명확한 책임을 가진 컴포넌트를 조합하여 프로그램을 작성해야 한다.
- '관심사 분리'와 '추상화'를 일관되게 적용하면 포트와 어댑터 아키텍처로 발전한다.
- 포트와 어댑터(Ports and Adapters) 아키텍처
    - 도메인 모델에 데이터베이스나 사용자 인터페이스 같은 기술적 기반 구조에 의존하지 않도록 분리하는 아키텍처다.
    - 모델 (Port)
        - 기술적 개념이 도메인 모델로 스며들지 않도록 인터페이스(Port)를 정의한다.
        - 애플리케이션 모델과 외부 세계의 관계를 비즈니스 용어로 표현한다.
    - 어댑터(Adapter)
        - 도메인 모델과 각 기술 도메인(DB, 외부 API 등) 사이에서 브리지(bridge) 역할을 수행하는 코드다.
        - 브리지는 애플리케이션 모델에서 정의한 인터페이스를 구현하고, 애플리케이션 객체와 기술 객체를 매핑한다.

> 캡슐화와 정보 은닉
>
> - 캡슐화(encapsulation)
>   - 객체의 행위가 해당 객체의 공개된 API를 통해서만 제어될 수 있도록 보장하는 것이다.
>   - 서로 관련 없는 컴포넌트 간에 불필요한 의존성이 없음을 보장하여, 한 객체의 변경이 다른 객체에 미치는 영향을 통제할 수 있다.
>
> - 정보 은닉(Information Hiding)
>   - 객체가 내부 구현 세부 사항을 추상화된 API 너머로 숨기는 것이다.
>   - 내부 구현이 변경되더라도 외부 API가 바뀌지 않으며, 시스템 전체를 수정할 필요가 없다.
>
> 
> - 객체 지향 시스템에서는 변경 가능한 객체에 대한 참조(reference)를 공유하는, 이른바 별칭(aliasing)으로 알려진 효과를 통해 캡슐화를 위반할 수 있다.
> - 별칭은 객체 지향 시스템에서 통신을 위해 필수적인 요소지만, 의도하지 않은 별칭은 시스템에서 관련 없는 부분을 참조해 캡슐화와 정보 은닉이 깨질 수 있다.

## 6.2 내부 대 이웃

- 시스템을 설계할 때, 각 객체의 '내부'와 '이웃'을 구분해야 한다.
    - 객체는 자신이 담당할 책임과 함께 명확한 API를 가져야 한다.
    - 객체는 API를 통해 내부 접근을 캡슐화 하여 응집력 있는 추상화를 제공해야 한다.
    - 객체의 내부 구현 세부사항을 외부로부터 감춰야 한다.
- 객체는 메시지를 통해 의사소통 한다.
    - 직접 메시지를 주고받는 객체들을 이웃(peer)이라고 한다.
- 이러한 결정은 내부와 외부의 경계를 명확히 하여 시스템 내부 품질에 기여한다.
    - 객체의 내부 구현이 외부로 드러나면, 클라이언트는 그 구현 세부사항에 직접 의존하게 된다.
    - 한 객체의 내부 동작이 다른 객체에 퍼지면, 시스템 전체에 결합도가 증가하고, 변경의 영향이 코드 전반으로 확산되어 유지보수 비용이 증가한다.
    - 이 문제가 2장에서 살펴본 열차 전복 현상이다.

> 다양한 수준의 언어
>
> - 도우미 메서드로 가독성을 높일 수 있다.
>   - 메서드가 표현하는 기능의 의미를 명확히 드러내기위해 작고 목적이 분명한 메서드를 자유롭게 추가할 수 있다.
>   ```java
>   allowing(sniperListener).sniperStateChanged(with(aSniperThatIs(BIDDING)));
>   ```
>   - 코드가 읽는 문장처럼 자연스럽게 읽히게 하는 효과를 준다.
>   - 내부 도우미 메서드들은 일반적인 외부 API처럼 명명 관례를 따르는 대신 문맥 내의 용도를 나타낼 수 있다.
> - 객체 간 메시지 전달에서는 객체 지향적 방식을 사용하지만, 객체 내부에서는 함수형 스타일을 적용해 부수 효과가 없는 메서드와 값을 토대로 동작 방식을 구현한다.
> - 부수 효과가 없는 기능은 더 작은 컴포넌트로 코드를 조립해 상태를 공유하는 데서 오는 위험을 최소화할 수 있다.

## 6.3 단일 책임 원칙

- 모든 객체는 하나의 명확한 책임(responsibility) 만을 가져야 한다.
    - 객체를 확장하거나 새로운 서비스를 만들어낼지 판단할 때 중요한 기준이 된다.
- 하나의 역할이란 접속사(‘와’, ‘또는’) 없이 설명할 수 있어야 한다.
- 단일 책임 원칙은 여러 객체를 조합해 새로운 추상화를 만드는 데도 적용된다.
    - 여러 객체가 협력하여 구현된 행위라도, 자신만의 책임을 명확히 가져야 한다.

## 6.4 객체 이웃의 유형

- 객체 이웃의 세 가지 유형
    - 의존성(Dependencies)
        - 한 객체가 자신의 역할을 수행하기 위해 필요한 서비스를 제공하는 이웃이다.
        - 해당 객체는 이 서비스 없이는 기능을 수행하지 못하며, 객체를 생성할 수 없다.
    - 알림(Notifications)
        - 한 객체의 상태 변화나 이벤트를 전파하기 위해 존재하는 이웃이다.
        - 알림을 보내는 주체는 어떤 이웃이 듣고 있는지 모르기 때문에, 객체를 서로 분리해 준다.
    - 조정(Adjustments)
        - 객체의 행위를 더 큰 시스템의 요건에 맞게 조정하거나 통제하는 역할의 이웃이다.
        - 의사 결정을 내리는 정책 객체와 복합 객체인 경우 조정 역할을 맡기도 한다.
- 객체 이웃의 유형은 법칙이 아니라 설계를 돕는 구분 기준으로, 협력 객체가 사용되는 맥락을 파악하는 것이 중요하다.
    - 알림은 일반적으로 단방향으로 전달되며, 리스너(Listener) 사이에 간섭이 없도록 값을 반환하거나 콜백 하거나 예외를 던지지 않을 수 있다.
    - 의존성이나 조정은 직접적인 관계이므로 값 반환, 콜백, 예외를 던질 수 있다.

>새 거 아니면 헌 거다. 시도란 없다.
>
> - 의존성은 생성자를 통해 명시적으로 전달되어야 한다.
> - 객체의 프로퍼티 기반 의존성을 설정하는 방법은 불안정하다
>   - 프로그래머가 모든 의존성을 직접 기억하고 설정해야 한다.
>   - 새로운 의존성이 추가되더라도 기존 클라이언트는 오류 없이 컴파일이 가능하다.
>     - 최악의 경우 `NullPointException`이 발생할 수 있다.
> - 알림과 조정 관계는 느슨한 결합을 유지해야하므로 런타임 시점에 추가, 변경, 삭제가 가능해야 한다.

## 6.5 전체는 부분의 합보다 단순해야 한다

- 모든 객체는 다른 여러 객체로 구성되어 있다.
    - 내부적으로 구성 요소의 존재와 상호 작용을 감추고 외부에서 바라볼 때는 단순한 추상화를 표현해야 한다.
- '묻지 말고 말하라' 원칙만으로는 충분하지 않다.
    - 단순히 객체의 구조를 감추는 수준을 넘어, 복합 객체 전체가 단순한 추상화를 제공하도록 설계해야 한다.
- 복합 객체의 API는 내부 구성 요소의 API보다 단순해야 한다.
    - 상위 수준의 단순한 API를 제공하면 추상화 수준이 높아지고 시스템의 일관성이 유지된다.

## 6.6 콘텍스트 독립성

- “전체는 부분의 합보다 단순해야 한다”는 규칙이 객체가 정보를 충분히 감췄는지(캡슐화) 판단하는 기준이다.
- “콘텍스트 독립성”은 객체가 너무 많은 정보 또는 잘못된 정보를 감추고 있지는 않은지 판단하는 기준이다.
- 콘텍스트 독립적(Context Independent)
    - 자신이 실행되는 시스템에 대해 아무것도 알지 못하는 객체를 의미한다.
    - 이러한 객체는 다른 환경이나 시스템에서도 그대로 재사용 가능하며, 변경 없이 새로운 맥락(Context)에 적용할 수 있다.
    - 객체가 자신이 실행되는 콘텍스트에 대한 모든 정보는 외부에서 주입되어야 한다.
        - 생성자(Constructor)를 통해 전달되는 경우 -> 영구적인 관계
        - 메서드 인자(Method parameter)를 통해 전달되는 경우 -> 일시적인 관계`
- ‘가부장적인(Paternalistic)’ 접근법
    - 각 객체는 자신의 역할을 수행하는 데 필요한 정보만 전달받고, 역할 중심으로 책임을 분리하면 객체들이 일관된 추상화 수준 안에서 존재하게 된다.
    - 이 객체들의 연쇄는 결국 시스템의 경계에 도달하며, 그 지점에서 시스템은 외부적인 세부 사항을 인식하게 된다.

> 단일 도메인 허위
> - 클래스의 용어가 여러 도메인에서 유래한 경우, 해당 클래스가 브리지 계층의 일부가 아니라면 콘텍스트 독립성을 위반했을 가능성이 있다.

- 여러 객체로 구성된 시스템에서 콘텍스트 독립성을 지키면 객체 간의 관계가 명시적으로 정의된다.
    - 객체는 자신의 관계를 직접 관리하지 않아도 된다.
    - 객체는 더욱 단순하고 응집력 있는 구조를 유지할 수 있다.
- 콘텍스트 독립적인 객체들은 시스템 환경에 의존하지 않기 때문에 다양한 환경에서도 안정적으로 작동하는 변경 가능한 시스템을 만들어 나갈 수 있다.

## 6.7 올바른 정보 감추기

- 캡슐화를 잘못 적용하면 오히려 해로울 수 있다.
    - 코드의 의도를 이해하기 어렵다.
    - 객체 간 통합이 복잡해진다.
    - 객체를 조합하여 행위를 만들어내기 어려워 진다.
- 콘텍스트 독립성은 객체가 자신이 실행되는 환경을 알지 않아야 한다는 원칙이다.
- ‘러시아 인형’ 구조처럼 시스템은 계층적으로 구성되어 있으며, 각 계층은 어떤 정보를 감출지 명확하게 구분해야 한다.

## 6.8 우리 견해가 반영된 관점

- 좋은 객체 지향 설계
    - 개발 접근법의 기반이 된다.
    - 변화에 잘 대응할 수 있다.
    - 수정하기 쉬운 코드를 만든다.
