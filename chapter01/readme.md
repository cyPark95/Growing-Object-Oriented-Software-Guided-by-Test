# 1장 테스트 주도 개발의 핵심은 무엇인가?

## 1.1 학습 과정으로서의 소프트웨어 개발

- 거의 모든 프로젝트에는 새로운 요소가 포함되며, 예기치 못한 문제를 마주치게 된다.
- 개발자는 프로젝트를 진행하면서 기술과 도메인을 배우고, 고객과 사용자는 프로젝트를 통해 자신들의 요구와 조직의 특성을 더 잘 이해하게 된다.
- 개발 과정에서는 끊임없이 배움과 피드백, 오해의 발견과 수정이 이루어진다.
- 불확실한 변화를 예측하기 위해서는 도움이 될 프로세스가 필요하다.

## 1.2 피드백은 가장 기본적인 도구다

- 경험 기반 피드백은 시스템과 그 사용법을 배우는 가장 효과적인 방법이다.
- 주기적인 배포는 가정을 검증할 기회를 제공하며, 이를 통해 피드백이 완전해진다.
- 프로젝트는 초 단위에서 월 단위까지 다양한 피드백 고리로 구성되며, 이 고리들은 서로를 보완한다.
    - 안쪽 고리: 단위 코드와 시스템 통합 같은 기술적 세부 사항에 집중한다.
    - 바깥 고리: 애플리케이션이 사용자 요구를 충족하는지, 팀이 효과적으로 협력하는지 같은 조직적 측면에 집중한다.
- 배포 주기가 짧을수록 실제 사용자에게서 피드백을 받을 가능성이 높아지고, 이에 응답할 수 있다.

> 점진적이고 반복적인 개발
> - 점진적 개발: 계층별로 나중에 통합하는 대신, 하나의 작은 기능을 처음부터 끝까지 완성해 동작하게 만드는 방식
> - 반복적인 개발: 한 번에 완벽하게 만들려 하지 않고, 피드백을 통해 여러 차례 개선해 나가는 방식

## 1.3 변화를 돕는 실천법

- 시간이 지남에 따라 변화하는 소프트웨어를 안전하게 대응하려면 두 가지 기술적 토대가 필요하다.
    1. 자동화 테스트
        - 기존 기능은 유지한 상태로, 새로운 기능을 추가할 수 있다.
    2. 단순한 코드 유지
        - 가독성과 유지보수가 향상된다.
- 코드를 단순하게 유지하려면 중복 제거, 명확한 역할 표현, 지속적인 리팩토링이 필요하다.
- 테스트 스위트는 리팩토링 과정에서 발생할 수 있는 실수로부터 보호해주는 안전망이 된다.
- 많은 개발자가 테스트 작성을 지루하고 귀찮은 일로 여기지만, TDD는 테스트를 설계 과정으로 바꿔 이 문제를 해결한다.
- 테스트를 먼저 작성하면 코드의 의도가 명확해지고, 더 깔끔하고 모듈화된 구조를 유도한다.
- 결과적으로 TDD는 자동화된 회귀 테스트라는 안전망을 제공해, 변화에 자신감을 준다.

## 1.4 테스트 주도 개발 간단 정리

- TDD의 핵심 주기
    1. 실패하는 테스트 작성
    2. 테스트를 통과하는 최소한의 코드 작성
    3. 코드 리팩토링(구조 단순화, 중복 제거 등)
- 테스트를 먼저 작성할 때 얻는 혜택(설계 관점)
    - 끝나는 시점을 파악할 수 있기 때문에 다음 작업의 인수 조건이 명확해진다
    - 느슨하게 결합된 구성 요소를 만들게 된다.
    - 테스트 자체가 문서의 역할을 하기 때문에 코드에 대한 실행 가능한 설명이 더해진다
    - 완전한 회귀 스위트가 늘어난다.
- 테스트를 실행할 때 얻는 혜택(구현 관점)
    - 구현 내용을 인지한 상태에서 오류를 탐지할 수 있다.
    - 작업 완료 여부를 알 수 있어, 과도한 최적화나 불필요한 기능 추가를 막을 수 있다.

> 테스트 주고 대발의 황금률
>
> "실패하는 테스트 없이는 새 기능을 작성하지 말라."

> 리팩토링
> - 기존 코드의 동작 방식은 유지하면서 내부 구조를 개선하는 작업이다.
> - 리팩토링은 '안전'할 정도로 작은 규모로, 매번 테스트로 확인하면서 진행해야 한다.
> - 여러 번의 작은 리팩토링이 쌓여 큰 구조적 개선으로 이어진다.

## 1.5 좀 더 큰 그림

- 단위 테스트만으로는 TDD의 중요한 혜택을 놓칠 수 있다.
    - 실제로 시스템에서 호출되지 않거나 통합되지 못해 쓸모없는 코드가 될 수 있다.
- 개발은 인수 테스트(acceptance test)부터 시작한다.
- 인수 테스트의 역할
    - 실패하는 동안 기능이 아직 구현되지 않았음을 보여준다.
    - 테스트에 통과하면 기능이 완성되어 작업 종료를 보여준다.
    - 작성하는 코드가 실제로 필요한 코드인지 가능하게 도와준다.
- 인수 테스트 아래에서 단위 수준의 테스트/구현/리팩토링의 작은 주기를 반복하며 기능을 완성한다.
- 인수 테스트는 바깥쪽 큰 피드백 고리, 단위 테스트는 안쪽 작은 피드백 고리 역할로 상호 보완적이다.

## 1.6 전 구간 테스트

- 인수 테스트는 시스템 내부 코드를 직접 호출하지 않고, 전 구간 테스트(end-to-end test) 형태로 수행해야 한다.
    - 실제 외부 시스템과 상호작용을 포함한 검증을 통헤 실제 환경에서 제대로 동작하는지 알 수 있다.

> 전 구간 테스트가 중요한 이유
>
> - 시스템 내부 호출만으로 작성된 인수 테스트는 가짜 테스트에 불과하다.
> - 실제로 동작하는지 확인하기 위해 외부와의 상호작용까지 포함한 전 구간 테스트가 필요하다.

- 전 구간 테스트와 경계 간 테스트
    - 경계 간 테스트: 외부 시스템과의 상호작용만 검증
    - 전 구간 테스트: 배포 프로세스를 포함한 시스템 전체를 검증
- 자동화된 전 구간 빌드 주기
    - 소스 체크아웃 -> 컴파일 -> 단위 테스트 -> 시스템 통합하고 패키징 ->현실적인 환경에 배포 -> 외부 접근 지점에서 시스템 시험
    - 과정은 번거롭지만 오류 발생하기 쉬우므로 자동화에 적합하다.
- 시스템은 모든 인수 테스트가 통과해야 배포할 수 있다.
- 인수 테스트는 모든 것이 동작하고 있다는 확신을 준다.

## 1.7 테스트의 수준

- 테스트 계층 구조
    - 인수 테스트
        - 전체 시스템이 동작하는가?
        - 가능한 한 전 구간에 걸쳐 테스트가 이뤄져야 한다.
    - 통합 테스트
        - 변경할 수 없는 코드를 대상으로 코드가 동작하는가?
        - 서드 파티 코드를 대상으로 정의한 추상화 계층이 올바르게 동작하는지 검증한다.
        - 인수 테스트보다 빠른 피드백을 제공하고, 외부 패키지와 형상 문제를 바로잡을 수 있다.
    - 단위 테스트
        - 객체가 제대로 동작하는가? 객체를 이용하기가 편리한가?
        - 단위 테스트는 모든 프로그래밍 스타일과 시스템에서 공통적으로 적용 가능하다.

## 1.8 외부 품질과 내부 품질

- 외부 품질
    - 시스템이 고객과 사용자의 요구를 얼마나 충족하는지를 나타낸다.
    - 전 구간 테스트를 실행해보면 외부 품질을 확인할 수 있고, 팀이 도메인을 얼마나 잘 이해하고 있는지도 알 수 있다.
- 내부 품질
    - 시스템이 개발자와 관리자의 요구를 얼마나 충족하는지를 나타낸다.
    - 단위 테스트를 통해 깨진 클래스 여부를 파악할 수 있다.
    - 단위 테스트를 통해 클래스가 깨졌는지 여부를 파악할 수 있다.
    - 하지만 전체적으로 동작하는지 확인할 수 없다.
- 단위 테스트는 내부 품질 개선에 도움이 된다.
    - 단위 테스트를 위해선 독립된 환경에서 실행할 수 있도록 구조화 해야한다.
    - 단위 테스트를 위해선 명시적인 의존성과 호출하고 검증할 수 있는 명확한 책임이 동반된다.
- 소프트웨어 공학 용어로 느슨하게 결합돼고, 응집력이 높아야 한다.
- 단위 테스트를 작성하면 설계에 관한 즉각적인 피드백을 얻을 수 있다.
    - 테스트를 작성하기 어려운 경우 원인을 찾고 리팩토링을 통해 구조를 개선할 수 있는 기회로 삼아야 한다.

> 결합도와 응집도
> 
> - 결합도 (Coupling)
>   - 코드의 동작 방식을 얼마나 쉽게 변경할 수 있는지 나타내는 척도
>   - 결합도가 낮을수록 유지 보수가 쉽다.
> - 응집도 (Cohesion)
>   - 한 요소의 책임이 의미 있는 단위를 형성하는지 나타내는 척도
>   - 서로 관련 없는 기능을 한 클래스가 동시에 맡으면 응집도가 낮다.
>   - 한 클래스가 지나치게 쪼개져 전체 개념을 표현하지 못해도 응집도가 낮다.
>   - 응집도가 높을수록 기능이 잘 모여 있고 유지 보수가 쉽다.
